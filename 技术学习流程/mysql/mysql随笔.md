# 随笔
![](/技术学习流程/mysql/pic/2023-04-23-11-18-53.png)
1. id 不重要: 查询的序列号
2. select_type 不重要:查询类型：例子：SIMPLE：简单的select不使用union或子查询
3. table 不重要：表明
4. type **重要** ：
   1. const ：最多只有一行记录匹配，当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描
   2. **eq_ref** / **ref** ：相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。
   3. fulltext： 理解为效率较差但优先级高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。全文索引的优先级很高
   4. range： 索引范围查询，常见于使用 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()或者like等运算符的查询中。
   5. index： 索引全表扫描，把索引从头到尾扫一遍
   6. all : 全表扫描
5. key：真正用到的索引
6. key_len : 查询用到的索引长度（字节数），多列索引，留下这个列的值，算一下你的多列索引长度就知道有没有使用所有的列
   1. key_len**只计算where条件用到的索引长度**，而排序和分组就算用到了索引，也不会计算到key_len中。
7. rows：  这是mysql估算的需要扫描的行数
8. extra **重要**：
   1. distinct： select 中使用了distinct关键字
   2. using filesort： 表示mysql需要额外的排序操作，不能通过索引顺序达到排序效果，需要将其优化
   3. using index ： 覆盖索引扫描。查询在索引树中就可以查找到所需要的数据，性能正常
   4. using temporary ： 查询时候具有临时表  
9. ref列 ：如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段
   

字节B：
位Bit：
int 是 4个字节：32位
一次io操作是4k（字节）
为了将磁盘io控制在很小的数量级，选择一个高度可控的多路搜索树木 b+

## b+树怎么优化查询
1. io的次数取决于树的高度，假设高度h
2. 表数据大小：N，每个磁盘块能存储的大小： M， 公式：h = log（m+1）N （m越大h越小）
3. 每个磁盘块m = 磁盘块大小（固定4k/8k）/ 数据，所以磁盘块中的数据越小，磁盘块M越大，索引树越低
4. 结论：
   1. 这就是为什么每个数据项，即索引字段要尽量的小
   2. 这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高

## 对于索引的优化
1. 最左前缀匹配。（会一直从左向右直到遇到范围查找则停止）
   1. 我的条件是 a =1,b=1,c>1,d=1 
   2. 如果复合索引为(a,b,c,d),索引走到c就停止了，d不会走索引
   3. 如果我的复合索引为（a,b,d,c）,所有的都会走索引，因为查询优化器会给我自动优化
2. =和in可以乱序 ，如上
3. 索引列不能参与计算，保持列“干净” ： from_unixtime(create_time) = ’2014-05-29’ 改为 create_time = unix_timestamp(’2014-05-29’)。
4. 对索进行拓展而不是进行新建
5. （**重要**）尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)：举例子唯一索引 算出来值为1；若为性别，只有男女情况下，基数大的场景下，这个就无限趋于0；就没必要建立索引
   
### 索引

#### 物理存储角度：非聚簇索引，聚蔟索引

#### 逻辑角度 主键索引，非主键索引，复合索引，唯一索引

#### 查询回表怎么回事

#### MVCC流程
1. mvcc作用于读已提交，可重复读 （undolog /版本链 /readview）
   1. 所有的undolog通过回滚指针相连，共同组成版本链
      1. 此处不完全争取
      2. 版本链 = undolog（包含回滚指针） + record（原始数据）+ 事务id
      3. 对数据进行修改时不会直接覆盖数据而是会通过增加undolog的方式方便回滚
   2. readview
      1. 一个快照，存储当前活动的事务id（即未提交的事务），排序生成一个数组
   3. 使用方式
      1. 找到一条记录，找到该记录中当前的事务id，对比readview中该id所处的位置，如果该id在readview的最左边，说明该事务已经提交可以读取，若在右边，说明未提交，根据undolog中的回滚指针（roll-pointer）找到上一个版本，继续比对版本中事务id所处readview中的位置
      2. 如果处于该事务ID在readview最小和最大事务id之间，如果该id在readview中则不可以访问（表示该事务还没有提交，此时要沿着版本连向上找），如果id不在版本链中则可以访问
      3. 举例子：
         1. 事务id为2；版本链子是（1.3.4）；这个时候就可以访问
2. mvcc只会在RC和RR级别使用
   1. RC中：每次执行读操作时都会创建一个新的ReadView；因为读取的数据是读已提交，所以需要知道当前已经提交的事务
   2. RR中：
      1. 为了保证在整个事务中保证事务的一致性，第一次执行事务时候会创建readview，在该事务的处理期间，使用同一个readview，这样可以保证规避不可重复读的场景
      2. 幻读：其他事务在我的事务执行期间对查询范围插入行，RR中readview是固定所以其他事务在事务执行期间不能在查询范围内插入新的行，从而避免了幻读的问题。
      3. 间隙锁（Gap Lock）是一种为了防止幻读而设计的特殊锁形式，它在RR隔离级别下使用，但它仅是MVCC机制的一部分。间隙锁用于锁定索引记录之间的间隙，以防止其他事务在这些间隙中插入新的行；实际上它同时**锁定索引记录之间的间隙和索引记录本身**


![红色的是undolog日志，所有的记录（红色绿色）称为版本链](/技术学习流程/mysql/pic/2023-07-24-15-42-25.png)


##### 当前读与快照读


## 慢sql优化
1. 看是否业务不可接受，设置sql——no——chache
2. where条件单表查，看那个条件区分度最高
3. explain看执行计划
4. order by limit 形式的sql语句让排序的表优先查！！
5. 了解业务方使用场景
6. 加索引

## 四种事物隔离级别

1. 读未提交
   1. 未提交的事务也可以读取，基本没有数据库用
2. 读已提交
   1. 已经提交的事务可以进行读取；一个事务要等到另一个事务提交后才能读取数据 -》oracle，sqlserver
3. 可重复读
   1. 即开始读取数据（事务开启）时，不再允许修改操作  -》 mysql
4. 串行读
   1. 脏，不可重复，幻读都不会出现

脏读：未提交的事务被读取，只有在读未提交时候才会出现
一个事务读取另一个未提交的数据。
![](/技术学习流程/mysql/pic/2023-05-25-17-45-33.png)

不可重复读
一个事务范围内两个相同的查询却返回了不同数据。
主要影响的是update操作，只有等update完成以后才能进行读取，在读已经提交时候最后出现（再升级就不可见）
![](/技术学习流程/mysql/pic/2023-05-25-17-48-40.png)

幻读
主要影响是insert操作，也是一个事务范围内，两次查询返回了不同的数据
![](/技术学习流程/mysql/pic/2023-05-25-17-50-54.png)

## 什么是 redo 和 undo 日志？？

## 存储引擎
不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能
MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated

InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。
![](/技术学习流程/mysql/pic/2023-07-05-11-40-12.png)


### 三范式
1. 如果每列都是**不可再分**的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF）
   1. ![](/技术学习流程/mysql/pic/2023-07-05-11-43-29.png)
2. 首先满足第一范式，并且表中非主键列**不存在对主键的部分依赖**。 第二范式要求每个表只描述一件事情。
   1. ![](/技术学习流程/mysql/pic/2023-07-05-11-43-07.png)
3. 满足第二范式，并且表中的列**不存在对非主键列的传递依赖**。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。
   1. ![](/技术学习流程/mysql/pic/2023-07-05-11-45-00.png)
   

### 存储过程
一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它

### 触发器
触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：
触发器是当对某一个表进行操作时触发

### 分库分表，结合自己的业务理解
垂直区分（商品，交易，报表），水平区分（pt）

## 数据主从库同步
![](/技术学习流程/mysql/pic/2023-07-19-16-29-18.png)

1. 主数据库将数据写到binary log（二进制日志）
   1. 用于记录对数据库进行的更改操作，它是 MySQL 的事务日志，记录了数据库的增删改操作，以二进制的形式存储在磁盘上。
2. 从库的io线程读取主库的binary log
3. 从库的io线程将数据读取到relay log（中继日志）
   1. 该日志不会持久化存储
4. mysql线程将中继日志内容读取替换到本地数据库中

## 数据库锁
innodb支持的三种锁
1. 行锁
   1. 锁直接加在记录上
2. 间隙锁
   1. 当使用间隙锁时，InnoDB会锁住一个索引范围，确保索引记录的间隙不变；间隙锁是针对事务隔离级别为可重复读或以上级别而已的。
3. Next-Key Lock
   1. 属于特殊的间隙锁，主要是间隙锁不会对索引范围两边的record加锁，但是next-key会
   2. 如果事务 A 锁定了键值范围 (10, 20]，那么 Next-Key Lock 不仅会锁定这个范围的间隙，**还会锁定键值为 10 和 20 的记录本身**（区别在此）。
4. 间隙锁是锁定索引记录之间的间隙。
   1. **当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。**
5. 何时能使用到间隙锁
   1. RR隔离级别下
   2. 查询条件必须有索引
   3. 间隙锁通过两个方面进行幻读的避免
      1. 防止间隙内有数据进行插入
      2. 防止在间隙外的数据通过update的操作移动到间隙内

