# JVM

## 对象回收方式
### 1.8
1.8的GC工具：Parallel Scavenge（新生代）+ Parallel Old（老年代）吞吐量，主要在意cpu执行时间与卡顿时间的比例
**注意学习CMS**
记住初始标记stw， 并发标记，重新标记stw，并发清理

// 上面是年轻代的gc机制
![](/技术学习流程/pic/2023-04-12-22-15-54.png)

### G1回收方式
简单知道：
g1跟cms前几种流程类似：初始标记，并发标记最终标记，筛选回收
不同的是cms是一个中标记清理策略，g1是标记整理清楚策略， 不会和cms一样使内存出现大量的不连续空间

### CMS
以短暂停为目的（采用标记清除算法）
流程： 初始标记(stw)，并发标记，重新标记(stw)，并发清理，并发重制
![](/技术学习流程/pic/2023-07-14-15-37-58.png)
缺点：
    1. 对cpu敏感，并发标记阶段虽然和用户线程一起标记作废对象，但是会占用一定的cpu资源，导致系统卡顿
    2. 会产生的不连续的内存空间
    3. 并发清理会产生有些无用的对象不被处理，在清理阶段，用户线程也在产生垃圾，清理不完全
       1. cms对此的应对策略是三色标记法

**CMS**三色是指黑白灰三色
1. 黑色：被root节点遍历到的节点，并且引用该节点的对象也已经遍历完成；黑色不能被指向白色
2. 灰色：至少存在一个引用该节点的对象没有被遍历到
3. 白色：没有被扫描到的节点，回收时候进行回收的节点
4. 流程
   1. 流程：一开始都是白色；被gcroot扫描就是灰色，再遍历灰色，灰色所有节点扫描玩就是黑色，没被遍历就是白色，重复遍历灰色。最后只有白色和黑色
   2. 出现漏标和错标问题
      1.  漏标，导致数据回收失败下次才能回收：本来白色节点已经与灰色节点关联了，但是灰色节点与黑色节点的关联被删除了，此时该灰色和白色都应该被删除，但是黑色节点不会重新扫描，而灰色节点扫描了下面的白色节点导致这两个节点不会删除
      2.  错标，本不应该删除的数据被删除了，黑色节点重新与白色节点进行关联，基于前提黑色节点不会继续扫描，所以上述白色节点本不应该被删除却被删除了
   3. 为了解决上述问题
      1. 提供了写屏障及增量更新的方式
      2. 出现新的节点以及旧的节点被切断的场景，记录下来，等扫描结束以后，对记录的节点重新进行扫描


## GCROOT节点
1.  java虚拟机栈中的引用的对象
2.  本地方法栈中的JNI（native方法）引用的对象
3.  **方法区中的类静态属性**引用的对象
4.  方法区中的常量引用的对象。 

