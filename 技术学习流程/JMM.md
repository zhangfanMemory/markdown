# JMM:java内存模型
背景： 由于处理器的运算速度与存储设备的运算速度之差距引出了：
    基于高速缓存的存储交互很好的解决了处理器和内存的速度矛盾，
        再引出了：但是为计算器引入了一个新的问题：缓存一致性（每个处理器都有职级的高速缓存，但是又公用同一主内存）
为了解决上述问题，提出内存模型
（多个处理器 -> 高速缓存） ->（一致性协议） -> （主内存）

作用：
内存模型（JMM）：用来屏蔽java对各种硬件和操作系统的内存访问差异，以实现java程序在各个平台下都能达到一致性的内存访问效果
主要目标：定义程序中的各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节（需要注意的是这里的变量：包含着**实例字段。静态字段**，构成数组对象的元素，不包含局部变量，因为局部变量是线程私有，不存在共享，不存在竞争问题）

## 内存模型的相关的操作和规则
1. 通过规定变量的使用，通过线程，主内存，工作内存三者之间的交互来使用变量
   1. 所有变量都在主内存
   2. 线程对变量的操作必须在工作内存中进行，不能直接读写主内存
   3. 不同线程之间无法访问对方的工作内存中的变量
2. java线程 <-> 工作内存 <-> sava/load操作 <-> 主内存
3. 主内存与工作内存通过以下8种方式进行交互，以下每种操作都是原子并不可再次分割的
   1. lock：工作于主内存，将主内存的变量加锁独占
   2. read：工作主内存，将主内存数据读取到线程的工作内存
   3. load：作用域工作内存：将read出来的值放置到工作内存的变量副本
   4. use：用于工作内存：将工作内存值使用，（传给执行引擎）
   5. assign：赋值：用于工作内存：将引擎接受的值赋予给工作内存变量->修改工作内存数据
   6. store：用于工作内存：将工作内存数据传给主内存
   7. write：主内存中：将store中的工作内存数据存的变量放到主内存变量中
   8. unlock：用于主内存：将锁释放，后续其他线程可再次锁定
4. 对于以上8个操作有以下几点规定
   1. read/load。store/write ：不能单独出现，必须一起说明取出来的值必须存在工作内存中，或者工作内存的数据更新后必须更新到主内存中
   2. assign使用完必须更新到主内存，后续需要store和write
   3. 一个新的变量必须在主内存诞生，所有工作内存的变量来自于主内存的副本
   4. “可重入锁”：可以多次lock但必须多次unlock且需要同一线程
   5. 如果没有lock则不能unlock
   6. 之行unlock之前必须将数据同步完到主存中
5. volatile **关键字**
   1. jvm提供的最轻量级的同步机制
   2. voatile只可以保证**可见性**，不能保证原子性（符合以下两种情况可以用volatile）
      1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
      2. 变量不需要与其他的状态变量共同参与不变约束
   3. 第二个语义（**禁止指令重拍**）
      1. （双检锁）
      2. 通过在volatile之前之后加上store和load相关内存屏障指令操作保证处理器不发生乱序
      3. 理解：其实禁止指令重排序也是基于内存指令屏障指令实现的，类似双简单锁，编译后有（lock addl $ 0x0,(%esp)）这个锁意味着我会将所有的修改同步到主存中，让你感觉我没有发生重排序：（**指令重排序无法越过内存屏障**）

## 模型的特征
1. 原子：8个内存屏障命令虚拟机：（lock/unlock）:提供了更高层次的字节码monitorenter/monitorexit 通过了synchronized释放给用户
2. 可见：只一个线程修改了变量可以立即被其他线程得知，三个关键字（volatile，final，synchronized）
3. 有序：表现在在线程内部有序，在外部线程看该线程，该线程是混乱状态
   1. 可以通过volatile/synchronized实现有序
   2. happens-before（先行发生原则）
      1. 4个线程
         1. 程序内有序
         2. thread的start先于内部发生
         3. thread的join终于内部发生
         4. 对线程中断的判断，在中断之后interupt
      2. 一个volatile/一个锁
         1. volatile写操作先于发生后面对这个变量的读操作
         2. unlock操作先于发生于后面对于同一个锁的lock操作
      3. 一个构造方法
         1. 对象的初始化先于finalize操作
      4. 一个传递
         1. a先于b，b先于c，那么a先于c