# java锁全部整理

![锁按其特性分类归纳](/2023-04-02-16-48-32.png)
![锁按其特性分类归纳](/技术学习流程/pic/2023-04-02-16-48-32.png)

学习java锁之前呢，需要先把AQS过一遍理解之后才会更容易理解锁的创造

从面试角度看： **以下必须弄懂**
1. 共享和排他优先
2. 锁升级
3. sync和lock
4. 重入
5. AQS

## 独享锁以及共享锁
简单概念：
如果一个线程对资源A加上排他锁，之后所有的线程都不能对该资源加上任何的锁，拥有排他锁的线程对资源拥有修改及读取的权限
如果一个线程对资源A加上共享锁，之后其他的线程对该资源也只能加上共享锁，拥有共享锁的线程只可以对资源进行读取操作
JDK中的synchronized和JUC中Lock的实现类就是互斥锁。
独享锁与共享锁也是通过**AQS**来实现的，通过实现不同的方法，来实现独享或者共享。
**学习使用ReentrantReadWriteLock**
![两把锁，read，write](/技术学习流程/pic/2023-04-02-17-00-20.png)

读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。
在最开始提及AQS的时候我们也提到了state字段（**int类型，32位**），该字段用来描述有多少线程获持有锁。
在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）
高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）
![](/技术学习流程/pic/2023-04-09-10-56-10.png)

写锁的枷锁流程：
![](/技术学习流程/pic/2023-04-09-11-05-15.png)
1. 有锁，但低16位是0（写锁为0），说明有读锁，则不能获取锁
2. 写入锁数量大于65535，则不能继续获取锁
3. 如果当前线程写入锁为0，当前线程需要阻塞（CAS获取锁失败），说明有锁正在获取中，则本线程获取锁失败
4. 支持重入锁的
   
必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作

读锁的流程：
![](/技术学习流程/pic/2023-04-09-11-16-10.png)
1. 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态
2. 如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，**依靠CAS保证**）增加读状态，成功获取读锁

## 锁升级
锁升级针对：synchronized
### synchronized 如何实现锁升级的
“Java对象头”、“Monitor”
synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的
**对象头**主要包括两部分数据：Mark Word（**标记字段**）、Klass Pointer（**类型指针**）。  


Mark Word（**标记字段**）:默认存储对象的HashCode，分代年龄和锁标志位信息
Klass Point（**类型指针**）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
 
 “Monitor”
Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。
synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的**操作系统的Mutex Lock**（互斥锁）来实现的线程同步。
依赖于Mutex Lock属于重量级锁，需要切换cpu状态来完成  

Mark Word内容
![](/技术学习流程/pic/2023-04-09-11-50-45.png)

1. 无锁：
   1. 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但**同时只有一个线程能修改成功**。
   2. 举例CAS
2. 偏向锁
   1. 偏向锁是指一段**同步代码一直被一个线程所访问**，那么该线程会自动获取锁，降低获取锁的代价。
   2. 当一个线程访问同步代码块并获取锁时，会在Mark Word里**存储锁偏向的线程ID**
   3. 引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为**轻量级锁的获取及释放依赖多次CAS原子指令**，而偏向锁**只需要在置换ThreadID的时候依赖一次CAS**原子指令即可。
3. 轻量级锁
   1. 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
   2. 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁
4. 重量级锁
   1. 此时等待锁的线程都会进入阻塞状态

## 公平或非公平锁
区别在于：公平锁在获取锁的时候会多一个方法，hasqueuedProcessors（）

hasqueuedProcessors（）
![](/技术学习流程/pic/2023-04-09-12-12-06.png)

主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。

## 可重入锁
可重入锁又名递归锁，是指在**同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁**（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

![](/技术学习流程/pic/2023-04-09-12-14-55.png)
同一个对象中的两个内置锁，如果是不可重入的锁，出现了dosomthing后再执行doother；需要事先释放对象锁才能执行dother，就会产生死锁

可重入锁实现：ReentrantLock
非可重入锁实现：NonReentrantLock

一个是每次state + 1，释放每次state -1；
另一个很直接设置为state = 1；释放的时候直接将state 设置为0

synchronized 锁：
    1. 可重入
    2.  不可中断 
    3.  非公平
Lock: 
    1. 可重入
    2. 可判断
    3. 可公平（两者皆可）