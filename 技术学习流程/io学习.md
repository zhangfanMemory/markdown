# io学习流程
## 用户态 & 内核态
**内核态**：内核本质是一种软件，控制计算机的硬件资源，并提供上层环境
**用户态**：上层应用程序活动空间，应用程序的执行要依赖于内核提供的资源，（包括cpu资源，存储资源，io资源）
**两者关系**：用户态的程序要访问内核态的资源可以通过：系统调用
**系统调用** ： 通过库函数及shell脚本进行封装，屏蔽复杂的底层实现细节，对系统调用进行封装提供简单接口个用户
**从用户态到内核态的其他种系统调用**
    1. 系统调用
    2. 异常：缺页异常，被动切换
    3. 外设中断：外设完成用户请求以后，会通知cpu发送中断信号。cpu会暂停即将执行的命令进而处理外设中断请求

## 五种io网络模型
### 阻塞io（bloking io）
**举例子**： 内核空间 -> 线程A -> 线程B ->线程C （工作队列）
    
&ensp;&ensp;当线程A要进行网络传输创建socket语句的时候，此时由**文件管理系统**创建一个由其管理的socket对象，这个对象包含发送缓冲区，接收缓冲区，等待队列；其中**等待队列**指向所有等待socket事件的线程  
    
&ensp;&ensp; 当线程执行到recv的时候，那么线程A就会移动到等待队列之后，此时工作队列没有线程A,所以线程A就不会占用cpu，而cpu轮训执行也只会执行线程BC  
    
应用进程调用recvform，执行系统调用，直到有数据报被拷贝到应用进程才返回，否则进程一直处于阻塞状态。**此时会把cpu给交出去不会一直占用**

### 非阻塞IO（non-blocking IO）：
用轮询的方式一直请求内核看数据有没有拷贝完，所以非阻塞io不会释放cpu会一直轮询，**造成cpu浪费**

### 信号驱动式IO（signal-driven IO）:
应用程序使用套接字进行信号驱动I/O，通过**sigaction系统调用**安装一个信号处理函数，用户进程运行不阻塞，当数据准备好以后，内核会发出一个sigio信号给信号处理函数，信号处理函数调用io操作处理数据。
缺点：信号IO在有大量的io操作的时候，会因为信号队列的溢出导致没法通知

### 异步IO（asynchronous IO）:
io多路复用是将**文件的句柄的状态**通知给用户线程，由用户自行读取数据处理数据，异步io是数据内核已经处理完了，并且**放在用户线程的指定的缓冲区域**，当用户线程得到通知后可以直接使用数据；