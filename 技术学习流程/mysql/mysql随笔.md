# 随笔
![](/技术学习流程/mysql/pic/2023-04-23-11-18-53.png)
1. id 不重要: 查询的序列号
2. select_type 不重要:查询类型：例子：SIMPLE：简单的select不使用union或子查询
3. table 不重要：表明
4. type **重要** ：
   1. const ：最多只有一行记录匹配，当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描
   2. **eq_ref** / **ref** ：相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。
   3. fulltext： 理解为效率较差但优先级高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。全文索引的优先级很高
   4. range： 索引范围查询，常见于使用 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()或者like等运算符的查询中。
   5. index： 索引全表扫描，把索引从头到尾扫一遍
   6. all : 全表扫描
5. key：真正用到的索引
6. key_len : 查询用到的索引长度（字节数），多列索引，留下这个列的值，算一下你的多列索引长度就知道有没有使用所有的列
   1. key_len**只计算where条件用到的索引长度**，而排序和分组就算用到了索引，也不会计算到key_len中。
7. rows：  这是mysql估算的需要扫描的行数
8. extra **重要**：
   1. distinct： select 中使用了distinct关键字
   2. using filesort： 表示mysql需要额外的排序操作，不能通过索引顺序达到排序效果，需要将其优化
   3. using index ： 覆盖索引扫描。查询在索引树中就可以查找到所需要的数据，性能正常
   4. using temporary ： 查询时候具有临时表  
9. ref列 ：如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段
   

字节B：
位Bit：
int 是 4个字节：32位
一次io操作是4k（字节）
为了将磁盘io控制在很小的数量级，选择一个高度可控的多路搜索树木 b+

## b+树怎么优化查询
1. io的次数取决于树的高度，假设高度h
2. 表数据大小：N，每个磁盘块能存储的大小： M， 公式：h = log（m+1）N （m越大h越小）
3. 每个磁盘块m = 磁盘块大小（固定4k/8k）/ 数据，所以磁盘块中的数据越小，磁盘块M越大，索引树越低
4. 结论：
   1. 这就是为什么每个数据项，即索引字段要尽量的小
   2. 这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高

## 对于索引的优化
1. 最左前缀匹配。（会一直从左向右直到遇到范围查找则停止）
   1. 我的条件是 a =1,b=1,c>1,d=1 
   2. 如果复合索引为(a,b,c,d),索引走到c就停止了，d不会走索引
   3. 如果我的复合索引为（a,b,d,c）,所有的都会走索引，因为查询优化器会给我自动优化
2. =和in可以乱序 ，如上
3. 索引列不能参与计算，保持列“干净” ： from_unixtime(create_time) = ’2014-05-29’ 改为 create_time = unix_timestamp(’2014-05-29’)。
4. 对索进行拓展而不是进行新建
5. （**重要**）尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)：举例子唯一索引 算出来值为1；若为性别，只有男女情况下，基数大的场景下，这个就无限趋于0；就没必要建立索引
   

## 慢sql优化
1. 看是否业务不可接受，设置sql——no——chache
2. where条件单表查，看那个条件区分度最高
3. explain看执行计划
4. order by limit 形式的sql语句让排序的表优先查！！
5. 了解业务方使用场景
6. 加索引